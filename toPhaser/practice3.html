<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
		<title>Phaser - Making your first game, part 9</title>
	<script type="text/javascript" src="phaser.min.js"></script>
		<style type="text/css">
				body {
						margin: 0;
				}
		</style>
</head>
<body>

<script type="text/javascript">

var game = new Phaser.Game(window.innerWidth, window.innerHeight, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update:update });

function preload() {
	game.load.image('ship', 'rocket.png');
	game.load.image('planet', 'planet2.png');
	game.load.physics('shipPhysics', 'tracedRocket.json');
	game.load.image('explosion', 'explosion.jpg');
}

	function create() {


		game.physics.startSystem(Phaser.Physics.P2JS);
		// game.physics.p2.gravity.y = 40;

		//turn on impact events for the world so we have collision callbacks
		game.physics.p2.setImpactEvents(true)

		cursors = game.input.keyboard.createCursorKeys();

		var shipCollisionGroup = game.physics.p2.createCollisionGroup();
		var terrainCollisionGroup = game.physics.p2.createCollisionGroup();

		const octagon = function(radius, start_x, start_y) {
			const edgeLength = radius/Math.sqrt(4+(2 * Math.sqrt(2))) * 2;
			const v1_x = start_x;
			const v1_y = start_y;
			const v2_x = start_x + edgeLength;
			const v2_y = start_y;
			let finalArray = [[v1_x, v1_y], [v2_x, v2_y]];
			return finalArray;
		}

		const createPlanet = function(array, numSegs, height, roughness) {
		  var points = [];
		  var height = height || 180;
		  var displace = height / 10;
		  var roughness = roughness || 1;
		  var numSegs = numSegs;

		  let edgeLength = array[1][0] - array[0][0];
		  const segLength = edgeLength/numSegs;
		  let power = Math.pow(2, Math.ceil(Math.log(edgeLength) / (Math.log(2))));

		  // TOP OF OCTAGON
		  let x = array[0][0]
		  let y = array[0][1];
		  for(var j = 0; j < numSegs - 1; j++){
		    x += segLength;
		    y += (Math.random()*displace*2) - displace;
		    points.push(x);
		    points.push(y);
		    displace *= roughness;
		  }

		  // TOP RIGHT OF OCTAGON - work in progress
		  displace = height / 10;
		  for(j = 0; j < numSegs; j++){
		    x += (Math.random()*displace*2) + displace/2;
		    y += (Math.random()*displace*2) + displace/2;
		    points.push(x);
		    points.push(y);
		    displace *= roughness;
		  }

		  // RIGHT SIDE OF OCTAGON
		  displace = height / 10;
		  for(j = 0; j < numSegs; j++){
		    x += (Math.random()*displace*2) - displace;
		    y += segLength;
		    points.push(x);
		    points.push(y);
		    displace *= roughness;
		  }


		  // BOTTOM RIGHT OF OCTAGON - work in progress
		  displace = height / 10;
		  for(j = 0; j < numSegs; j++){
		    x -= segLength/1.6;
		    y += (Math.random()*displace*2) + displace/2;
		    points.push(x);
		    points.push(y);
		    displace *= roughness;
		  }


		  // BOTTOM OF OCTAGON
		  displace = height / 10;
		  points.push(x)
		  points.push(y)
		  for(j = 0; j < numSegs; j++){
		    x -= segLength;
		    y += (Math.random()*displace*2) - displace;
		    points.push(x);
		    points.push(y);
		    displace *= roughness;
		  }

		  // BOTTOM LEFT of OCTAGON - work in progress
		  displace = height / 10;
		  for(j = 0; j < numSegs; j++){
		    x -= (Math.random()*displace*2) + displace/2;
		    y -= (Math.random()*displace*2) + displace/2;
		    points.push(x);
		    points.push(y);
		    displace *= roughness;
		  }

		  // LEFT SIDE OF OCTAGON
		  displace = height / 10;
		  points.push(x)
		  points.push(y)
		  for(j = 0; j < numSegs; j++){
		    x -= (Math.random()*displace*2) - displace;
		    y -= segLength;
		    points.push(x);
		    points.push(y);
		    displace *= roughness;
		  }

		  // TOP LEFT OF OCTAGON - work in progress
		  displace = height / 10;
		  for(j = 0; j < numSegs; j++){
		    x += segLength/2;
		    y -= (Math.random()*displace*2) - displace/10;
		    points.push(x);
		    points.push(y);
		    displace *= roughness;
		  }
		  x = (array[0][0] + x)/2;
		  y = (array[0][1] + y)/2;
		  console.log(x);
		  console.log(y);
		  points.push(x);
		  points.push(y);

		  return points
		};

		//var octagonArray = octagon(1000, window.innerWidth/3, window.innerHeight/2);
		var octagonArray = octagon(window.innerWidth/1.4, 500, 150);


		poly = new Phaser.Polygon(createPlanet(octagonArray, 10, 250, 1.05));
		graphics = game.add.graphics(100, 100);

		graphics.beginFill(0xeaeaea); // light gray
		graphics.drawPolygon(poly.points);
		graphics.endFill();

		terrain = game.add.sprite(window.innerWidth/2, window.innerHeight * 1.7, graphics.generateTexture());
		terrain.anchor.set(0.5);
		graphics.destroy();


		// set terrain collision
		game.physics.p2.enable(terrain);
		terrain.body.setCollisionGroup(terrainCollisionGroup);
		terrain.body.collides([terrainCollisionGroup, shipCollisionGroup]);
		terrain.body.static = true;


		// createing ship
		ship = game.add.sprite(game.world.width/2, game.world.height/5, 'ship');
		ship.scale.setTo(0.05, 0.05)

		// var graphics = game.add.graphics(0, 0);
		// graphics.beginFill(0xFF0000, 1);
		// graphics.drawCircle(300, 300, 20);

		// ship = game.add.sprite(300, 300, graphics.generateTexture());
		// graphics.destroy()



		// game.physics.p2.enable(ship);
		game.physics.p2.enable(ship, true);
		// ship.body.clearShapes();
		//this line throw error - can't read length of null
		// ship.body.loadPolygon('shipPhysics', 'ship');

		ship.body.collideWorldBounds = true;
		ship.body.setCollisionGroup(shipCollisionGroup);

		// ship.setCollisionGroup()
		ship.body.collides(terrainCollisionGroup, hitTerrain, this);

	};

//function that will be run when we hit the terrain
function hitTerrain(body1, body2) {
		//  body1 is the space ship (as it's the body that owns the callback)
		//  body2 is the body it impacted with, in this case our panda
		//  As body2 is a Phaser.Physics.P2.Body object, you access its own (the sprite) via the sprite property:
		
		//get the coordinates of the ship before it's destroyed so we can place the explosion at the same position
		let posX = ship.x;
		let posY = ship.y;
		// console.log('position of ship', posX, posY)
		console.log('hit terrain')
		ship.destroy();

		//create explosion sprite for collision
		explosion = game.add.sprite(posX, posY, 'explosion')
		// console.log('position of explosion', posX, posY)
		explosion.scale.setTo(0.05, 0.05)
		window.setTimeout(() => explosion.destroy(), 500)


		// explosion.destroy();
		// body2.sprite.alpha -= 0.1;

	}



	function update() {
			// left key, rotate ship
			if (cursors.left.isDown) {
				terrain.body.rotation -= 0.005;
				ship.body.rotateLeft(100);
			}
			// right key, rotate ship
			else if (cursors.right.isDown){
				terrain.body.rotation += 0.005;
				ship.body.rotateRight(100);
			}
			// stop rotating if key is not pressed
			else {
				ship.body.setZeroRotation();
			}
			// up key, accelerate
			if (cursors.up.isDown){
				ship.body.thrust(200);
			}
			// down key, reverse accelerate
			else if (cursors.down.isDown){
				//ship.body.reverse(200);
			}
	}

	</script>

	</body>
</html>
