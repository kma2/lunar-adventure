<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
	    <title>Lunar Adventure</title>
		<script type="text/javascript" src="phaser.min.js"></script>
	    <style type="text/css">
	        body {
	            margin: 0;
	        }
	    </style>
	</head>
	<body>

		<script type="text/javascript">

		var game = new Phaser.Game(window.innerWidth, window.innerHeight, Phaser.AUTO, '', { preload: preload, create: create, update: update });
		//game.world.setBounds(0, 0, window.innerWidth, window.innerHeight * 2);

		function preload() {
			game.load.image('planet', 'planet2.png');
			game.load.image('rocket', 'rocket.png');
		}

		var player;
		var platforms;
		var cursors;

		function create() {

		    //  We're going to be using physics, so enable the Arcade Physics system
		    game.physics.startSystem(Phaser.Physics.ARCADE);

				//  Our controls.
		    cursors = game.input.keyboard.createCursorKeys();


				// //  The platforms group contains the planet and the 2 ledges we can jump on
		  //   platforms = game.add.group();
		  //   platforms.enableBody = true;

				const octagon = function(radius, start_x, start_y) {
          const edgeLength = radius/Math.sqrt(4+(2 * Math.sqrt(2))) * 2;
          const v1_x = start_x;
          const v1_y = start_y;
          const v2_x = start_x + edgeLength;
          const v2_y = start_y;
          let finalArray = [[v1_x, v1_y], [v2_x, v2_y]];
          return finalArray;
        }

				const createPlanet = function(array, numSegs, height) {
          var points = [];
          var height = 250;
          var displace = height / 8;
          var roughness = 0.8;
          var numSegs = numSegs;
          let edgeLength = array[1][0] - array[0][0];
          const segLength = edgeLength/numSegs;
          let power = Math.pow(2, Math.ceil(Math.log(edgeLength) / (Math.log(2))));

          // TOP OF OCTAGON
          let x = array[0][0]
          let y = array[0][1];
          for(var j = 0; j < numSegs - 1; j++){
            x += segLength;
            y += (Math.random()*displace*2) - displace;
						points.push(new Phaser.Point(x, y));
            // points.push(x);
            // points.push(y);
            displace *= roughness;
          }

          // TOP RIGHT OF OCTAGON - work in progress
          displace = height / 10;
          for(j = 0; j < numSegs; j++){
            x += (Math.random()*displace*2) + displace/2;
            y += (Math.random()*displace*2) + displace/10;
            // points.push(x);
            // points.push(y);
						points.push(new Phaser.Point(x, y));
            displace *= roughness;
          }

          // RIGHT SIDE OF OCTAGON
          displace = height / 10;
          for(j = 0; j < numSegs; j++){
            x += (Math.random()*displace*2) - displace;
            y += segLength;
            // points.push(x);
            // points.push(y);
						points.push(new Phaser.Point(x, y));
            displace *= roughness;
          }

          // BOTTOM RIGHT OF OCTAGON - work in progress
          displace = height / 10;
          for(j = 0; j < numSegs; j++){
            x -= segLength/1.6;
            y += (Math.random()*displace*2) + displace/2;
            // points.push(x);
            // points.push(y);
						points.push(new Phaser.Point(x, y));
            displace *= roughness;
          }

          // BOTTOM OF OCTAGON
          displace = height / 10;
          // points.push(x)
          // points.push(y)
					points.push(new Phaser.Point(x, y));
          for(j = 0; j < numSegs; j++){
            x -= segLength;
            y += (Math.random()*displace*2) - displace;
            // points.push(x);
            // points.push(y);
						points.push(new Phaser.Point(x, y));
            displace *= roughness;
          }

          // BOTTOM LEFT of OCTAGON - work in progress
          displace = height / 10;
          for(j = 0; j < numSegs; j++){
            x -= (Math.random()*displace*2) + displace/2;
            y -= (Math.random()*displace*2) + displace/2;
            // points.push(x);
            // points.push(y);
						points.push(new Phaser.Point(x, y));
            displace *= roughness;
          }

          // LEFT SIDE OF OCTAGON
          displace = height / 10;
          // points.push(x)
          // points.push(y)
					points.push(new Phaser.Point(x, y));
          for(j = 0; j < numSegs; j++){
            x -= (Math.random()*displace*2) - displace;
            y -= segLength;
            // points.push(x);
            // points.push(y);
						points.push(new Phaser.Point(x, y));
            displace *= roughness;
          }

          // TOP LEFT OF OCTAGON - work in progress
          displace = height / 10;
          for(j = 0; j < numSegs; j++){
            x += segLength/2;
            y -= (Math.random()*displace*2) + displace/2;
            // points.push(x);
            // points.push(y);
						points.push(new Phaser.Point(x, y));
            displace *= roughness;
          }

          x = (array[0][0] + x)/2;
          y = (array[0][1] + y)/2;

					points.push(new Phaser.Point(x, y));
          return points;
        };

				var octagonArray = octagon(700, window.innerWidth/3, window.innerHeight/2);


				poly = new Phaser.Polygon(createPlanet(octagonArray, 10));
				graphics = game.add.graphics(100, 100);

				console.log('graphics ', graphics);
				console.log('poly ', poly.points);

				graphics.beginFill(0xeaeaea); // light gray
				graphics.drawPolygon(poly.points);
		    graphics.endFill();

				terrain = game.add.sprite(window.innerWidth/2, window.innerHeight * 1.3, graphics.generateTexture());
				terrain.anchor.set(0.5);
				graphics.destroy();
		}

		function update() {

		    // //  Collide the rocket and the stars with the platforms
		    // game.physics.arcade.collide(rocket, platforms);

		    // //  Reset the rockets velocity (movement)
		    // rocket.body.velocity.x = 0;

		    if (cursors.left.isDown) {
		        // rocket.body.velocity.x = -150;
		        // rocket.animations.play('left');
            terrain.rotation -= 0.05;
		    }
		    else if (cursors.right.isDown) {
		        // rocket.body.velocity.x = 150;
		        // rocket.animations.play('right');

						terrain.rotation += 0.05;
		    }
		    else {
		        // //  Stand still
		        // rocket.animations.stop();
		        // rocket.frame = 4;
		    }
		    //  Allow the rocket to jump if they are touching the planet.
		    if (cursors.up.isDown) { // && rocket.body.touching.down)
		        // rocket.body.velocity.y = -350;
		    }
		}


		</script>
	</body>
</html>
