<!doctype html>
<html>
  <head>
    <link rel="stylesheet" href="./style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.1.1/pixi.min.js"></script>
  </head>

  <body onLoad='init()'>
    <!-- <script async dfer src=/bundle.js></script> -->

    <script>

        // Autodetect, create and append the renderer to the body element
        var renderer = PIXI.autoDetectRenderer(window.innerWidth-5, window.innerHeight-5, {antialias: false, transparent: false, resolution: 1});
        document.body.appendChild(renderer.view);

        // Create the main stage for your display objects
        var stage = new PIXI.Container();

        var graphics = new PIXI.Graphics();

        // generates the coordinates of a octagon
        const octagon = function(radius, start_x, start_y) {
          const edgeLength = radius/Math.sqrt(4+(2 * Math.sqrt(2))) * 2;

          const v1_x = start_x;
          const v1_y = start_y;
          const v2_x = start_x + edgeLength;
          const v2_y = start_y;

          let finalArray = [[v1_x, v1_y], [v2_x, v2_y]];

          return finalArray;
        }

        var mainPlanetArray = octagon(250, 500, 150);
        var largeAsteroid = octagon(120, 1000, 300);
        var mediumAsteroid = octagon(60, 200, 75);
        var smallAsteroid = octagon(30, 900, 150);

        // draws a planet shape edge by edge
        const createPlanet = function(array, numSegs, height) {
          var points = [];
          var height = height || 180;
          var displace = height / 10;
          var roughness = 0.8;
          var numSegs = numSegs;

          let edgeLength = array[1][0] - array[0][0];
          const segLength = edgeLength/numSegs;
          let power = Math.pow(2, Math.ceil(Math.log(edgeLength) / (Math.log(2))));

          // TOP OF OCTAGON
          let x = array[0][0]
          let y = array[0][1];
          // points.push(x)
          // points.push(y)
          for(var j = 0; j < numSegs - 1; j++){
            x += segLength;
            y += (Math.random()*displace*2) - displace;
            points.push(x);
            points.push(y);
            displace *= roughness;
          }

          // TOP RIGHT OF OCTAGON - work in progress
          displace = height / 10;
          for(j = 0; j < numSegs; j++){
            x += (Math.random()*displace*2) + displace/2;
            y += (Math.random()*displace*2) + displace/2;
            points.push(x);
            points.push(y);
            displace *= roughness;
          }

          // RIGHT SIDE OF OCTAGON
          displace = height / 10;
          // x = array[2][0]
          // y = array[2][1];
          // points.push(x)
          // points.push(y)
          for(j = 0; j < numSegs; j++){
            x += (Math.random()*displace*2) - displace;
            y += segLength;
            points.push(x);
            points.push(y);
            displace *= roughness;
          }


          // BOTTOM RIGHT OF OCTAGON - work in progress
          displace = height / 10;
          // x = array[3][0];
          // y = array[3][1];
          for(j = 0; j < numSegs; j++){
            x -= segLength/1.6;
            y += (Math.random()*displace*2) + displace/2;
            points.push(x);
            points.push(y);
            displace *= roughness;
          }


          // BOTTOM OF OCTAGON
          displace = height / 10;
          // x = array[4][0]
          // y = array[4][1];
          points.push(x)
          points.push(y)
          for(j = 0; j < numSegs; j++){
            x -= segLength;
            y += (Math.random()*displace*2) - displace;
            points.push(x);
            points.push(y);
            displace *= roughness;
          }

          // BOTTOM LEFT of OCTAGON - work in progress
          displace = height / 10;
          for(j = 0; j < numSegs; j++){
            x -= (Math.random()*displace*2) + displace/2;
            y -= (Math.random()*displace*2) + displace/2;
            points.push(x);
            points.push(y);
            displace *= roughness;
          }

          // LEFT SIDE OF OCTAGON
          displace = height / 10;
          // x = array[6][0]
          // y = array[6][1];
          points.push(x)
          points.push(y)
          for(j = 0; j < numSegs; j++){
            x -= (Math.random()*displace*2) - displace;
            y -= segLength;
            points.push(x);
            points.push(y);
            displace *= roughness;
          }

          // TOP LEFT OF OCTAGON - work in progress
          displace = height / 10;
          for(j = 0; j < numSegs; j++){
            x += segLength/2;
            y -= (Math.random()*displace*2) - displace/10;
            points.push(x);
            points.push(y);
            displace *= roughness;
          }
          x = (array[0][0] + x)/2;
          y = (array[0][1] + y)/2;
          console.log(x);
          console.log(y);
          points.push(x);
          points.push(y);

          return points
        };


        var graphics = new PIXI.Graphics();

        graphics.beginFill(0xeaeaea);

        graphics.drawPolygon(createPlanet(mainPlanetArray, 10));
        graphics.drawPolygon(createPlanet(largeAsteroid, 4));
        graphics.drawPolygon(createPlanet(mediumAsteroid, 2, 90));
        graphics.drawPolygon(createPlanet(smallAsteroid, 2, 45));
        graphics.endFill();



        // Add the graphics to the stage
        stage.addChild(graphics);

        // Start animating
        animate();
        function animate() {
          // graphics.rotation += 0.05;
            renderer.render(stage);
            requestAnimationFrame(animate);
        }

    </script>


    <!-- <script>
        function init() {
        // keyState object to check keydown / keyup status
        var keyState = {};

        // create renderer
        var renderer = PIXI.autoDetectRenderer(window.innerWidth-5, window.innerHeight-5, {antialias: false, transparent: false, resolution: 1});
        renderer.backgroundColor = 0x444444;
        // renderer.autoResize = true;
    		document.body.appendChild(renderer.view);

    		//Create a container object called the `stage` (camera)
    		var stage = new PIXI.Container();
    		stage.position.x = window.innerWidth / 2 ;
    		stage.position.y = window.innerHeight;
    		stage.velocity = 0;

    		// load images
    		PIXI.loader
      		.add('planet2.png')
      		.add('rocket.png')
      		.load(setup);

    		//This `setup` function will run when the image has loaded
    		var planet, rocket
    		function setup() {

    	  	//Create the `planet` sprite from the texture
    	  	planet = new PIXI.Sprite( PIXI.loader.resources["planet2.png"].texture );
    			planet.position.x = 0;
    			planet.position.y = 1700;

    			//anchor will be needed to calculate the axis of rotation
    			planet.anchor.x = 0.5;
    			planet.anchor.y = 0.5;

    			//size
    			planet.width = 4000;
    			planet.height = 4000;

    			//radius will be very important to detect the collision
    			planet.radius = 500;

    			//create rocket
    			rocket = new PIXI.Sprite( PIXI.loader.resources["rocket.png"].texture )
    			rocket.position.x = 0// window.innerWidth / 2
    			rocket.position.y = -window.innerHeight / 1.5;
    			rocket.anchor.x = 0.5;
    			rocket.anchor.y = 0.5;
    			rocket.width = 40;
    			rocket.height = 100;
    			rocket.velocity = 0

    			//radius will be very important to detect the collision
    			rocket.radius = 10;


    		  //Add the planet and rocket to the stage
    		  stage.addChild(planet);
    		  stage.addChild(rocket)
          stage.addChild(graphics);

    		  gameLoop()
    		}

    		window.addEventListener('keydown', function (e) {
    		    var key = e.keyCode;
    		    keyState[event.keyCode || event.which] = true;
    		})

    		window.addEventListener('keyup', function (e) {
    		    var key = e.keyCode;
    		    keyState[event.keyCode || event.which] = false;
    		})


    		function checkKeyStates () {
    			if (keyState[38] || keyState[87]) rocket.position.y -= 10;
    			if (keyState[40] || keyState[83]) rocket.position.y += 10;
    			if (keyState[37] || keyState[65]) {
    				if (rocket.rotation > -0.5) rocket.rotation -= 0.1;
    				if (rocket.position.x > -400)	{
    					// rocket.velocity += 0.05;
    		  		rocket.position.x -= 10;
    		  		// rocket.position.x -= Math.abs(rocket.velocity);
    		  	} else {
    		  		planet.rotation += 0.01;
    		  	}
    			}
    			if (keyState[39] || keyState[68]) {
    				if (rocket.rotation < 0.5) rocket.rotation += 0.1;
    				if (rocket.position.x < 400)	{
    					// rocket.velocity -= 0.05;
    		  		rocket.position.x += 10
    		  		// rocket.position.x += Math.abs(rocket.velocity);
    		  	} else {
    		  		stage.velocity = 0.01;
    		  		planet.rotation -= stage.velocity;
    		  	}
    			}

    			// make rocket straight when all keys are up
    			if (rocket.rotation !== 0 && (!keyState[37] && !keyState[65] && !keyState[39] && !keyState[68])) {
    				if (rocket.rotation < 0) rocket.rotation += 0.01;
    				else rocket.rotation -= 0.01;
    			}
    		};

    		//Loop this function 60 times per second
    		function gameLoop(){
    		  requestAnimationFrame(gameLoop);
    		  requestAnimationFrame(checkKeyStates);

    		  // gravity
    		  rocket.position.y += 0.2;

    		  //Render the stage
    		  renderer.render(stage);
    		}
    	}
    </script> -->
  </body>
</html>
